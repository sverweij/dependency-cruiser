import { deepStrictEqual, strictEqual } from "node:assert";
import { rmSync } from "node:fs";
import { join } from "node:path";
import { isDeepStrictEqual } from "node:util";
import { describe } from "mocha";
import Cache from "../../src/cache/cache.mjs";

const OUTPUTS_FOLDER = "test/cache/__outputs__/";

describe("[I] cache/cache - readCache", () => {
  it("returns an empty cache when trying to read from a non-existing one", async () => {
    const lCache = new Cache();
    deepStrictEqual(await lCache.read("this/folder/does/not-exist"), {
      modules: [],
      summary: {},
    });
  });

  it("returns an empty cache when trying to read from a file that is invalid JSON", async () => {
    const lCache = new Cache();
    deepStrictEqual(
      await lCache.read("test/cache/__mocks__/cache/invalid-json"),
      {
        modules: [],
        summary: {},
      },
    );
  });

  it("returns the contents of the cache when trying to read from an existing, valid json", async () => {
    const lCache = new Cache();
    deepStrictEqual(
      await lCache.read("test/cache/__mocks__/cache/valid-minimal-cache"),
      {
        modules: [],
        summary: {},
        revisionData: {
          SHA1: "26fc7183127945393f77c8559f28bf623babe17f",
          changes: [],
        },
      },
    );
  });
});

describe("[I] cache/cache - writeCache", () => {
  before("remove __outputs__ folder", () => {
    rmSync(OUTPUTS_FOLDER, { recursive: true, force: true });
  });
  after("remove __outputs__ folder", () => {
    rmSync(OUTPUTS_FOLDER, { recursive: true, force: true });
  });

  it("writes the passed cruise options to the cache folder (which is created when it doesn't exist yet)", async () => {
    const lDummyCacheContents = {};
    const lCacheFolder = join(OUTPUTS_FOLDER, "write-cache");
    const lCache = new Cache();

    await lCache.write(lCacheFolder, lDummyCacheContents);
    deepStrictEqual(await lCache.read(lCacheFolder), lDummyCacheContents);
  });

  it("writes the passed cruise options to the cache folder (folder already exists -> overwrite)", async () => {
    const lDummyCacheContents = {};
    const lSecondDummyCacheContents = {
      modules: [],
      summary: {},
      revisionData: { SHA1: "dummy-sha", changes: [] },
    };
    const lCacheFolder = join(OUTPUTS_FOLDER, "two-writes");
    const lCache = new Cache();

    await lCache.write(lCacheFolder, lDummyCacheContents);
    await lCache.write(lCacheFolder, lSecondDummyCacheContents);
    deepStrictEqual(await lCache.read(lCacheFolder), lSecondDummyCacheContents);
  });

  it("writes the passed cruise options to the cache folder (which is created when it doesn't exist yet) - content based cached strategy", async () => {
    /** @type {import("../..").ICruiseResult} */
    const lDummyCacheContents = {
      modules: [],
      summary: { optionsUsed: { baseDir: "test/cache/__mocks__/cache" } },
      revisionData: { SHA1: "dummy-sha", changes: [] },
    };
    const lCacheFolder = join(OUTPUTS_FOLDER, "write-cache-content-strategy");
    const lCache = new Cache("content");
    const lRevisionData = { SHA1: "dummy-sha", changes: [] };

    await lCache.write(lCacheFolder, lDummyCacheContents, lRevisionData);
    isDeepStrictEqual(await lCache.read(lCacheFolder), lDummyCacheContents);
  });
});

describe("[I] cache/cache - canServeFromCache", () => {
  const lOriginalCacheFolder = join(
    OUTPUTS_FOLDER,
    "serve-from-cache-compatible",
  );
  /** @type import("../..").ICruiseResult */
  const lMinimalCruiseResult = {
    modules: [],
    summary: {
      optionsUsed: {
        cache: {
          folder: lOriginalCacheFolder,
          strategy: "metadata",
        },
        args: "src test tools",
      },
    },
    revisionData: { SHA1: "dummy-sha", changes: [] },
  };

  it("returns false when cache not written yet", async () => {
    const lCacheFolder = join(OUTPUTS_FOLDER, "serve-from-cache");
    const lEmptyCruiseResult = { modules: [], summary: [] };
    const lCache = new Cache();

    const lResult = await lCache.canServeFromCache(
      { cache: { folder: lCacheFolder, strategy: "metadata" } },
      lEmptyCruiseResult,
      {
        SHA1: "dummy-sha",
        changes: [],
      },
    );
    strictEqual(lResult, false);
  });

  it("returns false when the base SHA differs", async () => {
    const lCacheFolder = join(OUTPUTS_FOLDER, "serve-from-cache-sha-differs");
    const lCache = new Cache();
    const lFound = await lCache.canServeFromCache(
      {
        args: "src test tools",
        cache: { folder: lCacheFolder, strategy: "metadata" },
      },
      lMinimalCruiseResult,
      {
        SHA1: "another-sha",
        changes: [],
      },
    );

    strictEqual(lFound, false);
  });

  it("returns false when a file was added", async () => {
    const lCacheFolder = join(OUTPUTS_FOLDER, "serve-from-cache-file-added");
    const lCache = new Cache();
    const lFound = await lCache.canServeFromCache(
      {
        args: "src test tools",
        cache: { folder: lCacheFolder, strategy: "metadata" },
      },
      lMinimalCruiseResult,
      {
        SHA1: "dummy-sha",
        changes: [
          {
            changeType: "added",
            name: "some-new-file.aap",
            checksum: "dummy-checksum",
          },
        ],
      },
    );

    strictEqual(lFound, false);
  });

  it("returns false when cache written & revision data equal & options incompatible", async () => {
    const lCacheFolder = join(
      OUTPUTS_FOLDER,
      "serve-from-cache-options-incompatible",
    );
    const lCache = new Cache();
    const lFound = await lCache.canServeFromCache(
      {
        args: "src test tools configs",
        cache: { folder: lCacheFolder, strategy: "metadata" },
      },
      lMinimalCruiseResult,
      { SHA1: "dummy-sha", changes: [] },
    );

    strictEqual(lFound, false);
  });

  it("returns true when cache written & revision data equal & options compatible", async () => {
    const lCache = new Cache();
    const lFound = await lCache.canServeFromCache(
      {
        args: "src test tools",
        cache: { folder: lOriginalCacheFolder, strategy: "metadata" },
      },
      lMinimalCruiseResult,
      { SHA1: "dummy-sha", changes: [] },
    );

    strictEqual(lFound, true);
  });
});
